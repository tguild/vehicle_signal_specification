var relearn_search_index = [
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Ecosystem",
    "content": "VSS can be transformed into other formats or generated as code to integrate with other tooling environments and ecosystems.\nThe COVESA vss-tools project contains various helpful converters and is also used to validate the syntactic validity of the VSS standard catalogue.\nIf new features are introduced to the VSS specification, the community will ensure they are supported in the official vss-tools as well.\nFig 1. Generating various output formats from a VSS specification",
    "description": "VSS can be transformed into other formats or generated as code to integrate with other tooling environments and ecosystems.\nThe COVESA vss-tools project contains various helpful converters and is also used to validate the syntactic validity of the VSS standard catalogue.\nIf new features are introduced to the VSS specification, the community will ensure they are supported in the official vss-tools as well.\nFig 1. Generating various output formats from a VSS specification",
    "tags": [],
    "title": "Official VSS-Tools",
    "uri": "/vehicle_signal_specification/ecosystem/tools/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "Specification format The Vehicle Signal Specification domain specification consist of vspec files. vspec files are YAML files following the rule set defined for VSS. They also support the use of include directives to refer to other vspec files, much like #include in C/C++. . Please note that, from a YAML perspective, the include directive is just another comment.\nThe file VehicleSignalSpecification.vspec serves as root and includes other vspec files from the VSS repository.\nThe raw specification files can, with help of tools in the vss-tools repository, be converted to other formats that are more user friendly to read. Converted representations are also included as release artifacts for each VSS release.\nVSS is in itself case sensitive. This means that keywords, signal names, types and values normally shall be given with the case specified. It is however recommended not to take advantage of this and reuse the same name with different case, as some implementations may treat VSS identifiers as case insensitive.\nAddressing Nodes VSS supports only a single tree, that means that all signals must belong to the same root. In the VSS standard catalog the root branch is called Vehicle, so all signals must be part of the Vehicle tree.\nTree nodes are addressed, left-to-right, from the root of the tree toward the node itself. Each element in the name is delimited with a period (\".\"). The element hops from the root to the leaf is called path\nFor example, the dimming status of the rearview mirror in the cabin is addressed:\nVehicle.Cabin.RearviewMirror.Dimmed If there are an array of elements, such as door rows 1-3, they will be addressed with an index branch:\nVehicle.Cabin.Door.Row1.Left.IsLocked Vehicle.Cabin.Door.Row1.Left.Window.Position Vehicle.Cabin.Door.Row2.Left.IsLocked Vehicle.Cabin.Door.Row2.Left.Window.Position Vehicle.Cabin.Door.Row3.Left.IsLocked Vehicle.Cabin.Door.Row3.Left.Window.PositionIn a similar fashion, seats are located by row and their left-to-right position.\nVehicle.Cabin.Seat.Row1.Pos1.IsBelted # Left front seat Vehicle.Cabin.Seat.Row1.Pos2.IsBelted # Right front seat Vehicle.Cabin.Seat.Row2.Pos1.IsBelted # Left rear seat Vehicle.Cabin.Seat.Row2.Pos2.IsBelted # Middle rear seat Vehicle.Cabin.Seat.Row2.Pos3.IsBelted # Right rear seatThe exact use of PosX elements and how they correlate to actual positions in the car, is dependent on the actual vehicle using the spec.\nParent Nodes If a new leaf node is defined, all parent branches included in its name must be included as well, as shown below:\n[Signal] Vehicle.Cabin.Door.Row1.Left.IsLocked [Branch] Vehicle.Cabin.Door.Row1.Left [Branch] Vehicle.Cabin.Door.Row1 [Branch] Vehicle.Cabin.Door [Branch] Vehicle.Cabin [Branch] VehicleThe branches do not have to be defined in any specific order as long as each branch component is defined somewhere in the vspec file (or an included vspec file).\nDeprecation since version 2.1 During the process of model development, nodes might be moved or deleted. Giving developers a chance to adopt to the changes, the original nodes are marked as deprecated with the following rules.\nNodes, which are moved in the tree or are intended to be removed from the specification are marked with the deprecation keyword. The string following the deprecation keyword shall start with the version, when the node was deprecated starting with V (e.g. V2.1) followed by the reason for deprecation. If the node was moved, it shall be indicated by moved to followed by the new node name in dot notation as deprecation reason. This keyword shall be used only if the meta-data of the moved node hasn’t changed. If the node is intended to be removed from the specification or the meta data changed, it shall be indicated by removed and optionally the reason for the removal as deprecation reason. Nodes which are deprecated will be removed from the specification, either in the second minor update or, if earlier, the next major update. Example Vehicle.Navigation.CurrentLocation: type: branch description: The current latitude and longitude of the vehicle. deprecation: V2.1 moved to Vehicle.CurrentLocationIt is recommended for servers, which are implementing protocols for the vehicle signal specification, to serve old and new nodes during the deprecation period described above.\nStyle Guide The VSS specification must adhere to YAML syntax. To keep the standardized VSS specification in this repository consistent the following style guide is provided.\nNaming Conventions Node names in VSS must follow the restrictions specified in Yaml i.e. must only use the printable subset of the Unicode character set.\nTools and Generators supporting VSS may however put additional restrictions on which characters that are allowed. For maximum portability, node names in the VSS standard catalog must fulfill the following rules\nNode names in the VSS standard catalog shall use camel case notation starting with a capital letter. Node names in the VSS standard catalog shall use only A-Z, a-z and 0-9 in node names. Boolean signals must start with Is. Node names are case insensitive for comparison operations, therefore the full path of node names must be unique e.g. Vehicle.Abc and Vehicle.ABC are the same in comparison and therefore the presence of both is prohibited. Examples:\nVehicle.Cabin.Door.Row1.Left.IsLockedNaming convention for string literals can be found in the chapterfor specifying allowed values.\nLine Length It is recommended that line length for files in this repository ( e.g. *.vspec and *.md files) shall not exceed 120 characters. This is not a strict limit, it is e.g. not recommended to split long URLs over multiple lines.",
    "description": "Specification format The Vehicle Signal Specification domain specification consist of vspec files. vspec files are YAML files following the rule set defined for VSS. They also support the use of include directives to refer to other vspec files, much like #include in C/C++. . Please note that, from a YAML perspective, the include directive is just another comment.\nThe file VehicleSignalSpecification.vspec serves as root and includes other vspec files from the VSS repository.",
    "tags": [],
    "title": "Basic Rules",
    "uri": "/vehicle_signal_specification/rule_set/basics/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "A branch entry describes a tree branch (or node) containing other branches and signals.\nA branch entry example is given below:\nTrunk: type: branch description: All signals related to the rear trunk aggregate: falseThe following elements are defined:\nBody.Trunk The list element name defines the dot-notated signal name to the signal. Please note that all parental branches included in the name must be defined as well.\ntype The value branch specifies that this is a branch entry (as opposed to a signal entry). This is the default, in case type is omitted.\ndescription Describes the meaning and content of the branch. Recommended to start with a capital letter and end with a dot (.).\ncomment [optional] since version 3.0 A comment can be used to provide additional informal information on a branch. This could include background information on the rationale for the branch, references to related branches, standards and similar. Recommended to start with a capital letter and end with a dot (.).\ninstances [optional] For specifying that multiple instances of this branch exist, for more information see documentation on instances.\naggregate [optional] Defines whether or not this branch is an aggregate. If not defined, this defaults to false. An aggregate is a collection of signals that make sense to handle together in a system. A typical example could be GNSS location, where latitude and longitude make sense to read and write together. This is supposed to be deployment and tool specific, and for that reason no branches are aggregates by default in VSS. For branches that both have instances defined and aggregate: true, then aggregate refers to the signals for individual instances, i.e. signals for different instances can be handled separately.",
    "description": "A branch entry describes a tree branch (or node) containing other branches and signals.\nA branch entry example is given below:\nTrunk: type: branch description: All signals related to the rear trunk aggregate: falseThe following elements are defined:\nBody.Trunk The list element name defines the dot-notated signal name to the signal. Please note that all parental branches included in the name must be defined as well.\ntype The value branch specifies that this is a branch entry (as opposed to a signal entry).",
    "tags": [],
    "title": "Branch Entry",
    "uri": "/vehicle_signal_specification/rule_set/branches/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Introduction",
    "content": "What is VSS? The Vehicle Signal Specification introduces a domain taxonomy for vehicle signals. In short this means that VSS introduces:\nA syntax for defining vehicle signals in a structured manner. A catalog of signals related to vehicles. It can be used as standard in automotive applications to communicate information around the vehicle, which is semantically well defined. It focuses on vehicle signals, in the sense of classical attributes, sensors and actuators with the raw data communicated over vehicle buses and data which is more commonly associated with the infotainment system alike.\nA standardized vehicle data specification allows an industry actor to use a common naming space for communication and, ultimately, abstracts underlying vehicle implementation details.\nWhile the data in the VSS standard catalog aims to be vendor-independent, vendor specific extensions and adaptations complying with the VSS syntax rules can be specified (see Overlays).\nWhat’s in Standardized data definition for vehicle signals. Same semantic understanding across different domains. Basic definition for interfaces working on vehicle data (w3c, etc.). What’s out Everything outside the vehicle signal domain (customer, weather, etc.). Concrete interface definition. Example The figure below shows an example snapshot of a generated tree of the specification. The leafs contain the actual information as shown in the figure. Before going into detail of the specification, let’s dig deeper into taxonomies.\nVSS usage for other domains The VSS catalog focuses on signals related to vehicles. It is not the intention of the VSS project to add signals for other domains. The syntax used for defining VSS signals and related tooling could however be used to define similar signal trees for other domains.",
    "description": "What is VSS? The Vehicle Signal Specification introduces a domain taxonomy for vehicle signals. In short this means that VSS introduces:\nA syntax for defining vehicle signals in a structured manner. A catalog of signals related to vehicles. It can be used as standard in automotive applications to communicate information around the vehicle, which is semantically well defined. It focuses on vehicle signals, in the sense of classical attributes, sensors and actuators with the raw data communicated over vehicle buses and data which is more commonly associated with the infotainment system alike.",
    "tags": [],
    "title": "Overview",
    "uri": "/vehicle_signal_specification/introduction/overview/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Ecosystem",
    "content": "Other standards or specifications sometimes reference VSS.\nW3C VISS When using VSS in an automotive tech stack, a question is which protocols and technologies to use to access VSS signals.\nThe W3C Vehicle Information Service Specification (VISS) is an open standard, specifying a protocol to access VSS data via websocket (VISSv1, VISSv2) or HTTP/MQTT (VISSv2).\nTo learn more check\nVehicle Information Service Specification (VISS) V1 published as a Discontinued Draft. Vehicle Information Service Specification (VISS) V2, feature complete and in process to enter the Candidate Recommendation stage. W3C VSSo If you want to interconnect VSS data with other domains, you might want to employ ontology-based tech stacks. The W3C VSS Ontology enables you to express VSS in form of an OWL ontology.\nTo learn more check\nVSSo Core: Vehicle Signal Specification Core Ontology ",
    "description": "Other standards or specifications sometimes reference VSS.\nW3C VISS When using VSS in an automotive tech stack, a question is which protocols and technologies to use to access VSS signals.\nThe W3C Vehicle Information Service Specification (VISS) is an open standard, specifying a protocol to access VSS data via websocket (VISSv1, VISSv2) or HTTP/MQTT (VISSv2).\nTo learn more check\nVehicle Information Service Specification (VISS) V1 published as a Discontinued Draft. Vehicle Information Service Specification (VISS) V2, feature complete and in process to enter the Candidate Recommendation stage.",
    "tags": [],
    "title": "Related Standards",
    "uri": "/vehicle_signal_specification/ecosystem/standards/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "Leaf nodes of the tree contain metadata describing the data associated to the node. In order to help application developers, who are using the specification, it makes a distinction between three types of signals - sensor, actuator - and attribute. The difference between sensors/actuators and attributes is that sensors/actuators typically have a publisher (or producer) that updates the signal value continuously when a change occur while an attribute has a set value that should typically not change more than once per ignition cycle.\nExamples and more information you’ll find in the Sensors \u0026 Actuators chapter and Attributes chapter.",
    "description": "Leaf nodes of the tree contain metadata describing the data associated to the node. In order to help application developers, who are using the specification, it makes a distinction between three types of signals - sensor, actuator - and attribute. The difference between sensors/actuators and attributes is that sensors/actuators typically have a publisher (or producer) that updates the signal value continuously when a change occur while an attribute has a set value that should typically not change more than once per ignition cycle.",
    "tags": [],
    "title": "Data Entry",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Introduction",
    "content": "The figure below explains the idea of a taxonomy as bridge between human and machine understanding of data. It is important to focus on a specific domain to get common understanding and acceptance. The link between two or more domain taxonomies can be seen as second step.\nComponents of a domain taxonomy A domain taxonomy, like VSS, consists of three important components, which will be discussed in detail in this documentation:\n1. Rule Set, as definition on how to describe the data definition syntactically.\n2. Data Definition, as description of the domain as a simple graph.\n3. Tools and Serialization, generates the serialization out of the data Definition for further usage.",
    "description": "The figure below explains the idea of a taxonomy as bridge between human and machine understanding of data. It is important to focus on a specific domain to get common understanding and acceptance. The link between two or more domain taxonomies can be seen as second step.\nComponents of a domain taxonomy A domain taxonomy, like VSS, consists of three important components, which will be discussed in detail in this documentation:",
    "tags": [],
    "title": "Taxonomies",
    "uri": "/vehicle_signal_specification/introduction/taxonomy/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Ecosystem",
    "content": "Various software frameworks and products exist to work with VSS data. Some are Open Source, some are commercial prducts and services. There are solutions to work with VSS in-vehicle, as well as using it in the cloud.\nThe best entry-point for an up-to-date introduction to VSS products and Use Cases is the COVESA VSS wiki.",
    "description": "Various software frameworks and products exist to work with VSS data. Some are Open Source, some are commercial prducts and services. There are solutions to work with VSS in-vehicle, as well as using it in the cloud.\nThe best entry-point for an up-to-date introduction to VSS products and Use Cases is the COVESA VSS wiki.",
    "tags": [],
    "title": "Software \u0026 Solutions",
    "uri": "/vehicle_signal_specification/ecosystem/software/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "VSS resembles primarily the physical structure of the vehicle, so quite often there is a need to repeat branches and data entries (e.g. doors, axles, etc). To avoid hard-coded repetitions of branches and data entries in the specification an instance-concept is supported. Instances remove the need of repeating definitions, by defining at the node itself how often it occurs in the resulting tree. They are meant as a short-cut in the specification and interpreted by the tools. As an example is shown below for doors:\nWhen expanded this corresponds to:\nDefinition How can I create instances for my branch? An instance can be defined in any branch. The instantiation is done for every node in the following path. Instances are defined with the key-word instances, followed by its definition, which can be either: a list of strings, where each element defines a single instance, e.g. ['DriverSide','PassengerSide'] results into two instances of every following data entry in the path, named DriverSide and PassengerSide a string, followed by a range defined through [n,m], with n,m as integer and n \u003c= m, which defines the number of instances. Position[1,4] results into 4 instances of every following data entry in the path, named Position1, Position2, Position3 and Position4. It is in VSS recommended to use 1 as start index for the first row/axle/position/… If multiple instances occur in one node or on the path to a data entry, the instances get combined, by the order of occurrence. Following the example above, four position instances will be created for each of the ‘DriverSide’ and ‘PasengerSide’ instances, resulting into a total number of 8 instances. How can I exclude child-nodes from instantiation? Often it makes sense to instantiate all child-nodes of a branch. But there could be cases, when nodes are linked more the general concept of a branch, but not to the single instance.\nTo exclude a child-node from the instantiation of the direct parent node, set the keyword instantiate to false (true by default). Please check the following example for details.\nExample The example from above in the specification:\n# Cabin.vspec Door: type: branch instances: - Row[1,2] - [\"DriverSide\",\"PassengerSide\"] description: All doors, including windows and switches #include SingleDoor.vspec Door Door.SomeSignal: datatype: uint8 type: attribute instantiate: false description: A door signal that should not be instantiated.# SingleDoor.vspec # # Definition of a single door # IsOpen: datatype: boolean type: actuator description: Is door open or closedResults in the following signals:\nVehicle.Cabin.Door.SomeSignal Vehicle.Cabin.Door.Row1.DriverSide.IsOpen Vehicle.Cabin.Door.Row1.PassengerSide.IsOpen Vehicle.Cabin.Door.Row2.DriverSide.IsOpen Vehicle.Cabin.Door.Row2.PassengerSide.IsOpenRedefinition It is possible to override the default instantiation provided by VSS by redefining the branch with different instantiation information. If multiple definitions of a branch exist with different instance definitions, then the last found definition will be used. As an example, if three row of doors are needed, then the default VSS instance definition can be overridden by redefining the Door branch as shown in the example below.\n#Redefinition changing number of rows from 2 to 3 #The redefinition must appear \"after\" the original definition Vehicle.Cabin.Door: type: branch instances: - Row[1,3] - [\"DriverSide\",\"PassengerSide\"] description: All doors, including windows and switchesRecommendations VSS is designed to cover a wide range of vehicles. This means that the default instantiation used in VSS may not fit every vehicle. An example can be seen in the windshield signals defined in Body.vspec, parts of them are shown below. VSS offers the possibility to control windshield heating separately for front and rear windshield, and VSS also gives the possibility to report washer fluid level separately for each windshield. This fits very well for a vehicle that has separate washer fluid containers for front and rear windshield and that offers heating for both windshields. But that is not the case for all vehicles, it is not even certain that all vehicles have two windshields. This sections gives recommendations on how to use VSS for a vehicle if the VSS specification does not offer an exact match of the capabilities of the vehicle.\nWindshield: type: branch instances: [\"Front\", \"Rear\"] description: Windshield signals Windshield.Heating: type: branch description: Windshield heater signals Windshield.Heating.Status: datatype: boolean type: actuator description: Windshield heater status. 0 - off, 1 - on Windshield.WasherFluid: type: branch description: Windshield washer fluid signals Windshield.WasherFluid.LevelLow: datatype: boolean type: sensor description: Low level indication for washer fluid. True = Level Low. False = Level OK.Recommendation: Instance Mismatch If a vehicle does not have as many instances as specified in VSS then one of the following methods are recommended:\nRedefine the branch. If a vehicle for example does not have a rear windshield then append a redefinition at the end of the VSS: Vehicle.Body.Windshield: type: branch instances: [\"Front\"] description: Windshield signals Accept that a branch Vehicle.Body.Windshield.Rear will exist in the generated VSS representation, use mechanisms outside VSS to ignore that branch Recommendation: Features shared among instances If a feature is shared among instances, it is recommended to publish that feature for all concerned instances.\nExample: In VSS washer fluid can be handled separately for front and rear windshield. If a vehicle use a common container serving both front and rear windshield, then it is recommended that the vehicle report information on that container in both Vehicle.Body.Windshield.Front.WasherFluid.LevelLow and Vehicle.Body.Windshield.Rear.WasherFluid.LevelLow.\nRecommendation: Features lacking for some instances Not all instances in a vehicle might have the same features. If e.g. the front windshield from the example above lack a heater, then it is recommended to use mechanisms outside VSS to ignore Vehicle.Body.Windshield.Front.Heating.",
    "description": "VSS resembles primarily the physical structure of the vehicle, so quite often there is a need to repeat branches and data entries (e.g. doors, axles, etc). To avoid hard-coded repetitions of branches and data entries in the specification an instance-concept is supported. Instances remove the need of repeating definitions, by defining at the node itself how often it occurs in the resulting tree. They are meant as a short-cut in the specification and interpreted by the tools.",
    "tags": [],
    "title": "Instances",
    "uri": "/vehicle_signal_specification/rule_set/instances/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "An include directive in a vspec file will read the file it refers to and the contents of that file will be inserted into the current buffer in place of the include directive. The included file will, in its turn, be scanned for include directives to be replaced, effectively forming a tree of included files.\nSee Fig 6 for an example of such a tree.\nFig 6. Include directives\nThe include directive has the following format:\n#include \u003cfilename\u003e [prefix] The \u003cfilename\u003e part specifies the path, relative to the file with the #include directive, to the vspec file to replace the directive with. Additionally, include paths to search for the file can be added when using vss-tools using the -I/--include-dirs. The order of include paths to be searched is first the relative path of the vspec specifying the include and then given include paths in the given order.\nThe optional [prefix] specifies a branch name to be prepended to all signal entries in the included file. This allows a vspec file to be reused multiple times by different files, each file specifying their own branch to attach the included file to.\nAn example of an include directive is:\n#include doors.vpsec chassis.doors The door.vspec section specifies the file to include.\nThe chassis.doors section specifies that all signal entries in door.vspec should have their names prefixed with chassis.doors.\nIf an included vspec file has branch or signal specifications that have already been defined prior to the included file, the new specifications in the included file will override the previous specifications.\nREUSING SIGNAL TREES Complete subtrees of signals can be reused by including them multiple times, attaching them to different branches each time they are included.\nAn example is given in Fig 7 where a generic door signal specification is included four times to describe all doors in the vehicle.\nFig 7. Reusing signal trees\nThe door.vspec file is included four times by the master root.vspec file. The signals of door.vspec, Locked, WinPos, and Open are attached on the front left and right doors of row 1 (front) and row 2 (back).\nIf door.vspec is changed, the changes will be propagated to all four doors.",
    "description": "An include directive in a vspec file will read the file it refers to and the contents of that file will be inserted into the current buffer in place of the include directive. The included file will, in its turn, be scanned for include directives to be replaced, effectively forming a tree of included files.\nSee Fig 6 for an example of such a tree.\nFig 6. Include directives\nThe include directive has the following format:",
    "tags": [],
    "title": "Includes",
    "uri": "/vehicle_signal_specification/rule_set/includes/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set",
    "content": "VSS defines the standard catalog for vehicle signals independent of the used protocol and environment. In order to adopt the specification we realize that certain additions and modifications to the standard catalog are necessary. VSS Overlays are meant to bring you a standardized way of handling those changes.\nThe following features with the intended usage patterns are currently supported:\nAdding new nodes: By adding nodes the standard catalog can be extended with proprietary concepts. Deleting nodes: Deleting nodes not relevant for the vehicle. Changing the value of existing metadata: The standard catalog defines metadata based on what is assumed to be an average vehicle. Configurations may differ slightly (e.g. the instantiation of number of available seats), or special situations that require a (limited) modification of existing metadata. Adding new key/value pairs as additional metadata: Extending the model with richer information is a fundamental feature enabled by the layer concept. For example, deploying VSS into a specific scenario or with a particular binding/technology often needs some additional information. Multiple layer files: VSS layers can be split into several files in order to clearly separate concerns. Layering allows all the features above to be applied in a composable manner. In order to keep a determinstic result a clear order has to remain. Scenarios for using Overlays The standard catalog is specified within COVESA and defines a common view of the major attributes, sensors and actuators of vehicles. This is used in many different scenarios, protocols and environments. Additional meta data might be required for data-governance, -quality or -sources. The instantiation of branches might not fit your vehicle. Proprietary signals might be needed for extending the specification for your own use-cases. Up to now you were on your own in these scenarios. Overlays give you the chance to change and modify the standard catalog in a standardized way.\nHow does it work? Simply said, the tooling accepts, n additional spec files, next to the original specification file, which can overwrite or extend data in the VSS tree defined by the original specification. Before you start you should know:\nOverlay files do not need to be valid specification files by themselves but the merged result counts In practice that means, that nodes in the overlay files (e.g. branches) do not need to specify all the required attributes (like type, description, …) if they are supposed to overwrite certain attributes of an already existing branch in vss. You can omit parent branches if there is no need to change them However, the tooling does not allow implicit branches by design. So if you are creating new branches in overlays they need to be correctly linked to an existing branch in vss. Order matters. The order on how the overlay files are passed in the cli command matters! An example is shown in the figure below. The Figure below illustrates an example of the main specification and two separate overlay files, an example call of the tooling and the resulting tree.\nFigure: Overview on how overlays work within VSS\n# In this overlay all parent branches are included. # If you do not want to change existing branches, it is not necessary to specify them. # Also note that some elements are missing required attributes (description) # but since those elements will be merged with the ones in VSS, the result is valid. Vehicle: type: branch Vehicle.Cabin: type: branch Vehicle.Cabin.NewBranch: #\u003c introduction of a new branch type: branch description: \"new test branch\" Vehicle.Cabin.NewBranch.HasNewSignal: #\u003c introduction of a new signal type: sensor description: \"new test signal\" datatype: int8 Vehicle.Cabin.Door: type: branch Vehicle.Cabin.Door.IsOpen: type: sensor #\u003c change of node type datatype: booleanFile: overlay_1.vspec\n# This overlay would not be valid on its own since `NewBranch` is missing. # When being applied in conjunction with the previous overlay, it would create # `HasNewAttribute` accordingly. Vehicle.Cabin.NewBranch.HasNewAttribute: #\u003c ...with a new attribute type: attribute description: \"new test attribute\" datatype: string Vehicle.Cabin.Door.IsOpen: type: sensor newKey: value #\u003c Add a new key to the node and add a value datatype: booleanFile: overlay_2.vspec\nNode content in Overlays If you are adding a node you need to specify all attributes required for that node type. If you are changing an existing node you typically only need to specify the name and what you would like to overwrite, like in the Vehicle.Speed example below. That also works for overwriting nodes that are created using instances. vss-tools will then look up the node name and merges the attributes.\n# Type and Datatype not needed Vehicle.Speed: unit: m/s # Overwriting the unit of a node created by instances also works Vehicle.Occupant.Row1.DriverSide.HeadPosition.Yaw: unit: mmDeleting nodes It is possible to delete nodes using the delete attribute. You can delete indidvidual signals, branches, instances or a particular signal in a particular instance. A few examples are shown below.\n# Removing IsChildLockActive for DriverSide on Second Row Vehicle.Cabin.Door.Row2.DriverSide.IsChildLockActive: datatype: boolean type: sensor delete: true # Removing Window for all Door instances Vehicle.Cabin.Door.Window: delete: true # Removing Vehicle.Speed Vehicle.Speed: delete: trueWhen using the delete argument vss-tools will print a summary on how many nodes that are removed.\nNodes deleted, given=6, overall=18The number for given represents number of nodes (branches/sensors/actuators/attributes) explicitly removed. The overall number represents total number, including child nodes for explicitly removed branches. More detailed output is given in debug mode.\nOverlays in the standard catalog With the feature of overlays, we introduced a new folder in the repository called overlays. In there you’ll find two additional folders:\nprofiles: Larger overlays to adapt VSS to a specific vehicle category, like motorbikes. extensions: Smaller overlays typically to be applied after applying profiles (if any). Warning DISCLAIMER: Use of overlays is a new concept for VSS. The overlays in those folders shall currently be seen as examples only, and are not part of the official VSS specification.",
    "description": "VSS defines the standard catalog for vehicle signals independent of the used protocol and environment. In order to adopt the specification we realize that certain additions and modifications to the standard catalog are necessary. VSS Overlays are meant to bring you a standardized way of handling those changes.\nThe following features with the intended usage patterns are currently supported:\nAdding new nodes: By adding nodes the standard catalog can be extended with proprietary concepts.",
    "tags": [],
    "title": "Overlay",
    "uri": "/vehicle_signal_specification/rule_set/overlay/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Each data entry specifies a datatype from the following set (from Franca IDL). Datatypes shall not be used for branch entry\nSupported datatypes Name Datatype Min Max uint8 unsigned 8-bit integer 0 255 int8 signed 8-bit integer -128 127 uint16 unsigned 16-bit integer 0 65535 int16 signed 16-bit integer -32768 32767 uint32 unsigned 32-bit integer 0 4294967295 int32 signed 32-bit integer -2147483648 2147483647 uint64 unsigned 64-bit integer 0 2^64 - 1 int64 signed 64-bit integer -2^63 2^63 - 1 boolean boolean value 0/false 1/true float IEEE 754-2008 binary32 floating point number -3.40e 38 3.40e 38 double IEEE 754-2008 binary64 floating point number -1.80e 308 1.80e 308 string character string (unicode) n/a n/a Strings Strings in VSS supports the unicode character set. Actual encoding like UTF-8 or UTF-16 is not specified by VSS, that is to up to the Protocol/API/SDK implementing VSS support to decide.\nArrays Besides the datatypes described above, VSS supports as well the concept of arrays, as a collection of elements based on the data entry definition, wherein it’s specified. By default the size of the array is undefined. By the optional keyword arraysize the size of the array can be specified. The following syntax shall be used to declare an array:\n# Array of datatype uint32, by default size of the array is undefined datatype: uint32[] # Optional: specified number of elements in the array arraysize: 5An example for the usage of arrays is Vehicle.OBD.DTCList which contains a list of Diagnostic Trouble Codes (DTCs) present in a vehicle.\nStructs VSS struct support is further described on this page.\nData Streams Data Entries, which describe sensors offering binary streams (e.g. cameras), are not supported directly by VSS with a dedicated datatype. Instead, they are described through the meta data about the sensor itself and how to retrieve the corresponding data stream.\nA camera can be a good example of it. The Data Entry for the camera and the corresponding video stream could look like:\nCamera: type: branch description: Information about the camera and how to connect to the video stream Camera.IsActive: type: actuator datatype: boolean description: If the camera is active, the client is able to retrieve the video stream Camera.URI: type: sensor datatype: string description: URI for retrieving the video stream, with information on how to access the stream (e.g. protocol, data format, encoding, etc.)In this example, it shows the usage of meta data about the status of the sensor. The camera can be set to active through the same data entry (actuator). A dynamic data entry (sensor) is used for the URI of the video stream. Information on how to access the stream is expected.",
    "description": "Each data entry specifies a datatype from the following set (from Franca IDL). Datatypes shall not be used for branch entry\nSupported datatypes Name Datatype Min Max uint8 unsigned 8-bit integer 0 255 int8 signed 8-bit integer -128 127 uint16 unsigned 16-bit integer 0 65535 int16 signed 16-bit integer -32768 32767 uint32 unsigned 32-bit integer 0 4294967295 int32 signed 32-bit integer -2147483648 2147483647 uint64 unsigned 64-bit integer 0 2^64 - 1 int64 signed 64-bit integer -2^63 2^63 - 1 boolean boolean value 0/false 1/true float IEEE 754-2008 binary32 floating point number -3.",
    "tags": [],
    "title": "Datatypes",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/data_types/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "Discover what the Vehicle Signal Specification is all about.",
    "description": "Discover what the Vehicle Signal Specification is all about.",
    "tags": [],
    "title": "Introduction",
    "uri": "/vehicle_signal_specification/introduction/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Structs are a newly introduced feature to the VSS-syntax. Please note that all VSS-tools exporters do not yet support structs.\nIntroduction VSS has historically supported only the following datatypes:\nInteger-based datatypes (e.g. uint8, int32) Float-based datatypes (float, double) String Boolean In addition to this VSS arrays of the datatypes given above has been supported. This has been considered insufficient for some use-cases. Typical examples are when something cannot be described by a single value, but multiple values are needed.\nA few hypothetical examples include:\nGPS locations, where latitude and longitude must be handled together Obstacles - where each obstacle may contain information like category, probability and location Errors/Warnings - where each item might contain information on category and priority as well as time stamp Based on this a syntax for supporting structs in VSS has been defined\nIntended usage The struct support in VSS is introduced to facilitate logical binding/grouping of data that originates from the same source. It is intended to be used only when it is important that the data is read or written in an atomic operation. It is not intended to be used to specify how data shall be packaged and serialized when transported.\nBy this reason VSS-project will not introduce shorter datatypes (like uint1,uint4) to enable bit-encoding of data. The order of elements in a struct is from a VSS perspective considered as arbitrary. The VSS project will by this reason not publish guidelines on how to order items in the struct to minimize size, and no concept for introducing padding will exist.\nStructs shall be used in VSS standard catalog only when considered to give a significant advantage compared to using only primitive datatypes.\nStructs vs. Aggregate VSS supports a keyword aggregate that can be used on branches to indicate that the branch preferably shall be read and written in atomic operations. The keyword is however currently not used in the standard catalog, and it is not known if any implementation exists that actually consider it. There have been criticism that aggregate changes the semantic meaning of branches and signals, i.e. that a signal is no longer handed as an independent object. The exact meaning of aggregate is furthermore not well defined by VSS. Shall for example a write request (or update of sensor values) be rejected by an implementation if not all signals in the branch are updated in the same operation? Semantic interpretation is also ambiguous if the branch contains a mix of sensors, attributes and actuators. Using structs as datatype is better aligned with the view that VSS signals are independent objects, and the semantic ambiguities related to aggregate are not present for structs.\nAggregate could however be useful as information on deployment level. It gives the possibility to indicate that in this particular deployment the signals in the branch shall be treated as an aggregate. Exact meaning of the aggregate keyword is then deployment specific. With this view, aggregate shall never be used in the standard catalog, but can be used in overlays for deployment-specific purposes.\nGeneral Idea and Basic Semantics A signal of struct datatype shall be defined in the same way as other VSS signals, the only difference would be that instead of using a primitive datatype there shall be a reference to a struct datatype. This means that structs can be used for all types of VSS signals (i.e. sensor, attribute and actuator). If a signal of struct datatype is sent or received, VSS expects all included items to have valid values, i.e. all items are mandatory. For example, if a struct contains the items A, B and C - then it is expected that the sent signal contains value for all items. If some items are considered optional then the value range of the items must be adapted to include values indicating “not available” or “undefined”, or additional items needs to be added to indicate which items that have valid values.\nVSS makes no assumption on how structs are transferred or stored by implementations. It is however expected that they are read and written by atomic operations. This means that the data storage shall be “locked” while the items of the struct are read, preventing changes to happen while reading/writing the items.\nStructs shall be defined in a separate tree intended for definition of datatypes only. This means that signal definitions and struct definitions cannot exist in the same files. Tooling must thus accept one (or more) parameters for specifying datatype definition(s). The tree must have a single branch as root, i.e. it is not possible to have a struct as root.\nCurrently no structs have been introduced to the VSS standard catalog, but it has been agreed that the VSS standard catalog type root shall be called Types, and that types added to VSS standard catalog will be added to the Types.Vehicle branch. For example, if a type for GNSS location would be added to the VSS standard catalog in the future, it may be called Types.Vehicle.GNSSLocationType. User extensions could then be added as sub-branches to Types, like Types.OEM.SomeOEMType.\nThe top level datatypes file(s) (e.g. vss_types.vspec) can refer to other datatype files similar to the top VSS file. It is possible to specify that multiple datatype files shall be used, but all datatypes must belong to the same root. This means if the first file defines A.B, then the seconds file can define A.C, but not X.Y as that would result in two roots (A and X).\nFor current vss-tools support for structs see documentation in the vss-tools repository.\nNaming Restrictions The VSS syntax and tooling shall not enforce any restrictions on naming for the datatype tree. It may even use the same branch structure as the signal tree. This means that it theoretically at the same time could exist both a signal A.B.C and a struct A.B.C. This is not a problem as it always from context is clear whether a name refers to a signal or a datatype.\nSimple Definition and Usage This could be a hypothetical content of a VSS datatype file\nTypes: type: branch Types.DeliveryInfo: type: struct description: A struct datatype containing info for each delivery Types.DeliveryInfo.Address: datatype: string type: property description: Destination address Types.DeliveryInfo.Receiver: datatype: string type: property description: Name of receiverThis struct definition could then be referenced from the VSS signal tree\nDelivery: datatype: Types.DeliveryInfo type: sensorThe datatype file may contain sub-branches and #include-statements just like regular VSS files\nTypes: type: branch Types.Powertrain: type: branch description: Powertrain datatypes. #include Powertrain/Powertrain.vspec Types.PowertrainName resolution Two ways of referring to a datatype are considered correct:\nIn Datatype Tree:\nReference by absolute path Reference by (leaf) name to a struct definition within the same branch In Signal Tree:\nReference by absolute path Relative paths (e.g. ../Powertrain.SomeStruct) are not allowed. Structs in parent branches will not be visible, in those cases absolute path needs to be used instead.\nThe reference by leaf name is applicable only for structs referencing other structs!\nExpectations on VSS implementations (e.g. VISS, KUKSA.val) It is expected of implementations to support atomic read/write/subscribe of complete signals defined with struct datatype. They may support read of parts of signal, e.g. DeliveryList.Receiver\nArray Support It is allowed to use a struct type in an array\nDeliveryList: datatype: Types.DeliveryInfo[] type: sensor description: List of deliveriesBy default the array has an arbitrary number of element and may be empty. If a fixed size array is wanted the keyword arraysize can be used to specify size:\nDeliveryList: datatype: Types.DeliveryInfo[] arraysize: 5 type: sensor description: List of deliveriesExpectations on VSS implementations (e.g. VISS, KUKSA.val) For array datatypes (like above) VSS implementations may support several mechanisms\nIt is expected that they can support read/write/subscribe of the whole array, i.e. write all or read all in the same request They may optionally support additional operations like Writing/Reading a single instance, e.g. DeliveryList[2] (index mechanism is implementation dependent) Appending/Deleting individual instances Searching for instances with specific conditions. Structure in Structure It is allowed to refer to a structure datatype from within a structure\nOpenHours: type: struct description: A struct datatype containing information on open hours OpenHours.Open: datatype: uint8 type: property max: 24 description: Time the address opens OpenHours.Close: datatype: uint8 type: property max: 24 description: Time the address close DeliveryInfo: type: struct description: A struct datatype containing info for each delivery DeliveryInfo.Address: datatype: string type: property description: Destination address DeliveryInfo.Receiver: datatype: string type: property description: Name of receiver DeliveryInfo.Open: datatype: OpenHours type: property description: When is receiver availableOrder of declaration/definition The order of declaration/definition shall not matter. As signals and datatypes are defined in different trees this is a topic only for struct definitions referring to other struct definitions. A hypothetical example is shown below. An item in the struct DeliveryInfo can refer to the struct OpenHours even if that struct is defined further down in the same file. If using --types \u003cfile\u003e multiple times all files except the first will be treated similar to overlays. This means that is allowed to define A.B.C in multiple files, but then subsequent (re-)definitions will overwrite what has been defined previously. Note that if type files want to use structs from other files that the dependent files are specified first. Therefore the order of given type files matters.\nDeliveryInfo: type: struct description: A struct datatype containing info for each delivery DeliveryInfo.Open: datatype: OpenHours type: property description: When is receiver available OpenHours: type: struct description: A struct datatype containing information on open hoursInline Struct Inline/anonymous structs are not allowed!\nDefault Values VSS supports default values.\nDefault values are not allowed for signals of struct datatype. This also mean that VSS does not need to specify notation for struct values. An exception is arrays of struct-datatypes, where “empty array”, i.e. [] shall be supported as default value.\nIt shall be possible to define default values for properties (unless the item is of struct datatype). If all items of a struct datatype have default values, then a signal (or item) using the struct datatype is also considered to have a default value.\nAllowed Values VSS supports specification of allowed values.\nUsing allowed for type: property is allowed (if allowed is supported for the used datatype). Using allowed for signals and items of struct datatype or array of struct datatype is not allowed.",
    "description": "Structs are a newly introduced feature to the VSS-syntax. Please note that all VSS-tools exporters do not yet support structs.\nIntroduction VSS has historically supported only the following datatypes:\nInteger-based datatypes (e.g. uint8, int32) Float-based datatypes (float, double) String Boolean In addition to this VSS arrays of the datatypes given above has been supported. This has been considered insufficient for some use-cases. Typical examples are when something cannot be described by a single value, but multiple values are needed.",
    "tags": [],
    "title": "Struct Types",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/data_types_struct/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "Governance The Vehicle Signal Specification (VSS) project is an initiative by COVESA to define a syntax and a catalog for vehicle signals.\nThe artifacts maintained by the VSS project consist of:\nSource code, documentation and releases in the VSS github repository. Tools for parsing and converting VSS files in the VSS-tools github repository. The VSS project has an informal structure with a chair and github maintainers appointed by COVESA. Tasks for the chair includes hosting regular meeting to discuss incoming pull requests and issues, as well as roadmap and release planning.\nContribution process Anyone may propose changes to VSS. It is up to the VSS project to decide if the changes are feasible to include in VSS. The VSS project does not have any developers or maintainers paid by COVESA. Instead, the VSS project relies on voluntary contributions, typically from member organizations. The maintainers are expected to review incoming pull requests. All contributions must follow the COVESA contribution guidelines.\nIn general, pull requests shall be opened for at least a week before being merged to give time for COVESA members to review the pull request and provide comments. In case of larger changes or changes that affect backward compatibility pull requests are typically opened for a longer period, to allow for a through review. Pull requests, unless trivial, are typically merged first after a decision at one of the regular VSS meetings, see link at COVESA VSS wiki page. These rules concerns primarily normative content (see below), non-normative content may be updated without thorough reviews.\nFor more information and guides on how to contribute see CONTRIBUTING.md.\nBranches VSS development is typically developed in the master branch only. Each release is tagged and a maintenance branch is created (e.g. release/3.0) which could be used as target for pull requests intending to patch a release.\nNormative vs. non-normative content The VSS repositories contain some artifacts that can be considered normative, i.e. an implementation claiming to “support” VSS shall:\nSupport signals defined according to the rules in the VSS documentation (source, generated) Support the signals currently defined in VSS. The signals in source format (*.vspec files) can be found in Github repository. Derived formats supported by VSS project are included in each release, originating from the tools in the VSS-tools github repository. In addition to this the VSS repositores contain artifacts that currently are considered non-normative. This includes immature concepts and work-in progress. Non-normative content include:\nVSS Github Wiki VSS Tools Wiki Overlays and Profiles Contributed tools The list of what is considered normative and non-normative is no static, it may change over time.\nHandling of backward compatibility The VSS project aims to keep backward compatibility as far as feasible. VSS is however an evolving syntax and catalog and there are still areas where changes are need to fit the need of users. Changes that breaks backward compatibility are typically introduced only in major releases (e.g. X.0) and shall be documented in release notes. This concerns changes to syntax and signals, but also to tools.\nThe VSS project has introduced a deprecation concept. If possible, when e.g. renaming or moving a signal or changing tools the old signal or parameter set shall be kept but marked as deprecated. That allows the change to be introduced in a minor version (e.g. X.Y). The old signal shall be removed first in the next major release, or later if needed.\nA history of past changes and planned changes that affects backward compatibility can be found in the Changelog.\nRelease Process The release process is further described in the Github repository.",
    "description": "Governance The Vehicle Signal Specification (VSS) project is an initiative by COVESA to define a syntax and a catalog for vehicle signals.\nThe artifacts maintained by the VSS project consist of:\nSource code, documentation and releases in the VSS github repository. Tools for parsing and converting VSS files in the VSS-tools github repository. The VSS project has an informal structure with a chair and github maintainers appointed by COVESA. Tasks for the chair includes hosting regular meeting to discuss incoming pull requests and issues, as well as roadmap and release planning.",
    "tags": [],
    "title": "Governance",
    "uri": "/vehicle_signal_specification/governance/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "The Rule Set of a domain taxonomy is used to describe how to write the data definition syntactically.\nThis chapter defines and describes the rule set for VSS. Tools in the vss-tools repository can be used to validate that a specification follows the rule set for VSS, but those tools may have limitations and may not check all rules stated in this document. In case of conflict, what is stated in the rule set in this documentation is considered to have precedence over tool implementations.\nVersion handling The source for the rule set is in VSS Git repository. The online version of the rule set in the generated VSS documentation is updated whenever a new commit is merged to the VSS master branch and does this not necessarily correspond to the rule set for the last release VSS version.\nTo highlight important changes to the VSS rule set two notations are used in the documen\nsince version X.Y means that the concept/syntax was introduced in version X.Y. Older tools not supporting VSS version X.Y may not support this concept/syntax. deprecated since version X.Y means that the concept/syntax is no longer recommended from version X.Y onwards. The concept/syntax may be removed in the next major release. ",
    "description": "The Rule Set of a domain taxonomy is used to describe how to write the data definition syntactically.\nThis chapter defines and describes the rule set for VSS. Tools in the vss-tools repository can be used to validate that a specification follows the rule set for VSS, but those tools may have limitations and may not check all rules stated in this document. In case of conflict, what is stated in the rule set in this documentation is considered to have precedence over tool implementations.",
    "tags": [],
    "title": "Rule Set",
    "uri": "/vehicle_signal_specification/rule_set/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Introduction to Data Units in VSS It is in VSS possible for signals to specify a unit of measurement from a list of predefined data units. For most signals in the VSS standard catalog, a data unit has been selected. A typical example is Vehicle.Speed, as shown below.\nVehicle.Speed: datatype: float type: sensor unit: km/h description: Vehicle speed.The ambition when selecting data unit for signals in VSS standard catalog has been to use either a unit based on SI-units, or a unit commonly used within the vehicle industry. For the Vehicle.Speed example above this means that km/h has been selected, even if m/s from an SI-perspective would have been a better choice.\nIt must be noted that the selected unit does not imply that the value of Vehicle.Speed always needs to be sent or visualized as km/h (with float as datatype). A user interface or API may show or request vehicle speed in any unit it likes, and a transport protocol may send speed in another unit, possibly also involving scaling and offset. But in protocols not explicitly specifying data units (like VISS) it is expected that Vehicle.Speed is sent and received as km/h (without scaling or offset). However since units define possible allowed-datatypes the given datatype has to match the allowed ones.\nVSS does not offer any syntax for defining alternative units for a specific signal. The VSS project has specified for all units a corresponding quantity e.g. velocity for km/h. An API may use the quantity information to identify alternative units that can be used to represent the signal. The VSS list of units does not specify conversion factors, so even if VSS list both km/h and m/s as units for the quantity velocity, it is not specified how they relate to each other.\nIn some cases it is natural to omit the data unit. This concerns typically signals where datatype string is used, but also signals where the value just represents a number (dimensionless quantities), like in the example below:\nVehicle.Cabin.DoorCount: datatype: uint8 type: attribute default: 4 description: Number of doors in vehicle.Logical Data Units VSS supports percent as data unit, typically with 0 to 100% as the allowed range. In some cases, the definition on how to calculate the signal value is obvious, like for Vehicle.Powertrain.FuelSystem.Level below. It is likely that all VSS users will calculate fuel level in the same way, i.e. the meaning of a fuel level of 50% is well agreed, the liters of fuel in the tank is exactly 50% of nominal capacity.\nVehicle.Powertrain.FuelSystem.Level: datatype: uint8 type: sensor unit: percent min: 0 max: 100 description: Level in fuel tank as percent of capacity. 0 = empty. 100 = full.In other cases, the formula for calculating the signal is not obvious and is not specified in VSS. A typical example is shown below for clutch wear. While most VSS users likely can agree that a brand new clutch shall have 0 as “ClutchWear”, the exact formula for calculating clutch wear for a used clutch will likely be vehicle specific. Some vehicles might monitor actual wear, others might estimate it based on vehicle usage. This is in VSS called a logical range, a VSS user knows what range to use but are free to define the formula for calculating the value. Values from different vehicles (of different make/model) can not always be compared, as the formula used for calculation may differ.\nVehicle.Powertrain.Transmission.ClutchWear: datatype: uint8 type: sensor unit: percent max: 100 description: Clutch wear as percent. 0 = no wear. 100 = worn.Supported Data Units in VSS Standard Catalog The VSS syntax does not in itself specify what units can be used, the unit attribute as declared for signals in *.vspec files is optional and can contain an arbitrary string value. VSS-Tools however require that all units used are defined and therefore is also a requirement for signals in the VSS standard catalog. Units are defined by including them in a unit file with syntax as described below. One or more unit files can be specified by the -u parameter and, if not given, the tools search for a file units.yaml in the same directory as the root *.vspec file.\nFor the VSS standard catalog the VSS-project has defined a set of units that can be used for signals in the VSS standard catalog. This list is composed of definitions according to International Units (SI) and few automotive-specific units: Specification, Wikipedia. It can be noted that not all units in the list are currently used by the VSS standard catalog, but they may be used in the future or may be used for customization of the VSS catalog.\nThe VSS list of units for the standard catalog exists in units.yaml.\nAddition of new Data Units to VSS standard catalog The list of units in VSS standard catalog is not static. New units can be added if needed for signals in the VSS standard catalog, or if the VSS-project considers that the unit might be useful for customization of the VSS tree. If you would like to propose a new unit to be added to the list please create a pull request where the new unit is added to units.yaml.\nIf the unit is needed for a new signal in the VSS standard catalog you can propose the new signal and the new unit in the same Pull Request.\nUnit file syntax Unit files follow the syntax defined below:\n[ \u003cvss-unit-identifier\u003e: # Typically unit abbreviation, like km/h or mm, but no special characters definition: \u003cstring\u003e [unit: \u003cstring\u003e] # Full name of unit, optional, if not given assumed to be equal to vss-unit-identifier quantity: \u003cstring\u003e # Quantity of the unit. [allowed-datatypes] : ['numeric', 'string', uint8', ...]] # Allowed datatypes in VSS standard catalog [deprecation: \u003creason\u003e] ]*The VSS term quantity corresponds roughly to the term quantity as defined in for example ISO 80000. Typical example are length, mass and velocity that all can be expressed in SI-units. However, from a VSS perspective quantities do not need to correspond to physical quantities. It could be an arbitrary term, but it is generally expected that it is possible to convert between values using different units but defined with the same quantity.\nExample:\nm: definition: Length measured in meters unit: meter quantity: length allowed-datatypes: ['numeric'] mm: definition: Length measured in millimeters unit: millimeter quantity: length allowed-datatypes: ['numeric']As m and mm are defined with the same quantity it is expected that you can convert a value from m to mm.\nThe allowed-datatypes attributes can be used to specify which VSS datatypes can contain values of a particular unit. For most units the symbolic datatype numeric meaning any float or integer datatype can be used. As an example, both uint8 and float can be used to represent a length value. If using uint8 you will have range restrictions, but that might be acceptable for some signals. For some units more specific datatype restrictions are relevant. Some examples:\nA date/time expressed in ISO 8061 format (unit: iso8601) can only be represented as a string A UNIX Timestamp signal (unit: unix-time) must be at least 32 bit unsigned to be able to handle date/time after year 2038. The deprecation keyword can be used to indicate that a specific unit may be removed in the future. Tooling shall preferably give a warning if a signal uses a deprecated unit or the unit used belongs to a deprecated quantity. The reason should preferably list when and why the unit is deprecated, a hypothetical example is given below:\ninch: definition: Distance measured in inches unit: inch quantity: distance deprecation: V5.0 replaced by 'in' in: definition: Distance measured in inches unit: inch quantity: distanceQuantity file syntax Defining of quantities is required. If tooling supports quantity files it can verify that all units provided in unit files use defined quantities. For the VSS standard catalog it is required that matching quantities have been defined for all units.\n[ \u003cvss-quantity-identifier\u003e: # Identifier preferably taken from a standard, like ISO 80000 definition: \u003cstring\u003e [remark: \u003cstring\u003e] # remark as defined in for example ISO 80000 [comment: \u003cstring\u003e] [deprecation: \u003creason\u003e] ]*The VSS list of quantities for the standard catalog exists in quantities.yaml.\nAddition of new Quantities to VSS standard catalog The list of quantities in VSS standard catalog is not static. New quantities can be added if needed for units in the VSS standard catalog, or if the VSS-project considers that the quantity might be useful for custom units. If you would like to propose a new quantity to be added to the list please create a pull request.\nIf the quantity is needed for a new unit in the VSS standard catalog you can propose the new quantity and the new unit in the same Pull Request.\nDefining custom units It is possible to define custom units in a unit file. Assume for instance you want to have a signal showing remaining range in furlong. Then you could add an additional unit furlong. No need to specify unit or symbol as they equals the default (i.e. “furlong”). As this unit is not commonly used and not described in any standards, it might be relevant to describe how it can be converted to other units. That is however only informative, as it a custom unit a downstream implementation supporting unit conversion may not support automatic conversion of furlong to other units.\nunits: furlong: definition: Length measured in furlong, 1 furlong equals 201.1680 m quantity: length allowed-datatypes: ['numeric']",
    "description": "Introduction to Data Units in VSS It is in VSS possible for signals to specify a unit of measurement from a list of predefined data units. For most signals in the VSS standard catalog, a data unit has been selected. A typical example is Vehicle.Speed, as shown below.\nVehicle.Speed: datatype: float type: sensor unit: km/h description: Vehicle speed.The ambition when selecting data unit for signals in VSS standard catalog has been to use either a unit based on SI-units, or a unit commonly used within the vehicle industry.",
    "tags": [],
    "title": "Data Units",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/data_units/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Sensors are signals to read values of properties in a vehicle. Values of sensors typically change over time. Reading a sensor shall return the current actual value of the related property, e.g. the current speed or the current position of the seat.\nActuators are used to control the desired value of a property. Some properties in a vehicle cannot change instantly. A typical example is position of a seat or a window. Reading a value of an actuator shall return the current actual value, e.g. the current position of the seat, rather than the wanted/desired position. A typical example could be if someone wants to change the position of a seat from 0 to 100. This can be changed by setting the corresponding actuator to 100. If the actuator is read directly after the set request it will still return 0 as it might take some seconds before the seat reaches the wanted position of 100. If the seat by some reason is blocked or cannot be moved due to safety reasons it might never reach the wanted position. It is up to the vehicle to decide how long time it shall try to reach the desired value and what to do if it needs to give up.\nA data entry for a sensor or actuator defines its members. A data entry example is given below:\nSpeed: type: sensor description: The vehicle speed. comment: For engine speed see Vehicle.Powertrain.CombustionEngine.Engine.Speed. datatype: float unit: km/h min: 0 max: 300Drivetrain.Transmission.Speed Defines the dot-notated name of the data entry. Please note that all parental branches included in the name must be defined as well.\ntype Defines the type of the node. This can be branch, sensor, actuator or attribute.\ndatatype The string value of the datatype specifies the scalar type of the data entry value. See datatype chapter for a list of available datatypes.\ndescription Describes the meaning and content of the signal. The descriptionshall together with other mandatory members like datatype and unit provide sufficient information to understand what the signal contains and how signal values shall be constructed or interpreted. Recommended to start with a capital letter and end with a dot (.).\ncomment [optional] since version 3.0 A comment can be used to provide additional informal information on a signal. This could include background information on the rationale for the signal design, references to related signals, standards and similar. Recommended to start with a capital letter and end with a dot (.).\nmin [optional] The minimum value, within the interval of the given datatype, that the data entry can be assigned. If omitted, the minimum value will be the “Min” value for the given datatype. Cannot be specified if allowed is defined for the same data entry.\nmax [optional] The maximum value, within the interval of the given datatype, that the data entry can be assigned. If omitted, the maximum value will be the “Max” value for the given datatype. Cannot be specified if allowed is defined for the same data entry.\nunit [optional] The unit of measurement that the data entry has. See Data Units chapter for a list of available units. This cannot be specified if allowed is defined for the same data entry.",
    "description": "Sensors are signals to read values of properties in a vehicle. Values of sensors typically change over time. Reading a sensor shall return the current actual value of the related property, e.g. the current speed or the current position of the seat.\nActuators are used to control the desired value of a property. Some properties in a vehicle cannot change instantly. A typical example is position of a seat or a window.",
    "tags": [],
    "title": "Sensors \u0026 Actuators",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/sensor_actuator/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": " Warning DISCLAIMER: The following information about open source licensing shall not be considered legal advice. For advice on licensing, COVESA suggests that you contact your open source officer or legal counsel.\nWhich license applies VSS as well as the VSS-tools are covered by the Mozilla Public License 2.0 (MPL-2.0). The MPL-2.0 is an OSI approved Open Source license that gives you a lot of freedom using VSS in your products, or for (academic) research. It also provides a solid legal framework if you choose to contribute to either the standards or the tools.\nWe will line out some answers to commonly asked questions, but keep in mind this page is informational. The legally binding clauses can be found in the license itself. If in doubt, consult your friendly neighborhood lawyer or IP department.\nCan I use VSS / VSS-tools in my commercial products Most definitely yes. You must inform your users that the product contains MPLed code and need to provide access to the source (e.g. by linking to this documentation or our Github repository).\nI modified VSS-tools, do I need to give away my source? If you use the code internally within your organisation (company), you have no obligations to do so. (see also Q5 here). If you distribute the modified vss-tools outside your organization (e.g. to your customers), you need to make the source code of the MPL-2.0 licensed parts available. However, the MPL has only a very weak copyleft effect. As a rule of thumb: You have no obligation to provide code in new files. You have the obligation to make code of changed existing MPLed files available under the clauses of the MPL-2.0, if you distribute them in source or compiled form outside your organisation ((see also Q9,10,11 here)).\nIn any case we do recommend you to consider sharing generally useful improvements with the community. Not only will you win karma points with the community and gain visibility as an innovation leader in the automotive industry, you will most likely also get more robust software as you will have more users and testers.\nI changed VSS or added custom signals to the standard catalog. Do I need to give them away? No. One important selling point of VSS is, that you can always extend the standard catalog with your own use case specific signals. There is no obligation to release any added signals or proprietary information to third parties.\nFrom an MPL-2.0 point of view the information of the previous question applies. To be extra sure, put any additions in separate files, and use the layering approach to modify the standard catalog. This community does not consider deleting elements from the standard catalog or adding VSS #include statements “modifications” in the sense of clause 1.10 of the MPL-2.0.\nAs with the tools, we do recommend you to consider sharing generally useful standard catalog improvements with the community.",
    "description": "Warning DISCLAIMER: The following information about open source licensing shall not be considered legal advice. For advice on licensing, COVESA suggests that you contact your open source officer or legal counsel.\nWhich license applies VSS as well as the VSS-tools are covered by the Mozilla Public License 2.0 (MPL-2.0). The MPL-2.0 is an OSI approved Open Source license that gives you a lot of freedom using VSS in your products, or for (academic) research.",
    "tags": [],
    "title": "License",
    "uri": "/vehicle_signal_specification/license/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "VSS is used in different products, solutions and use cases. This section will give some pointers to the wider VSS ecosystem",
    "description": "VSS is used in different products, solutions and use cases. This section will give some pointers to the wider VSS ecosystem",
    "tags": [],
    "title": "Ecosystem",
    "uri": "/vehicle_signal_specification/ecosystem/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "An attribute is an entity that has a default value, specified by its default member. The standard Vehicle Signal Specification does not include default values for all attributes. If a default value has not been specified then the OEM must define a default value matching the actual vehicle. If the standard defines a default value but it does not fit the actual vehicle, then the OEM must override the standard default value.\nAttribute values can also change, similar to sensor values. The latter can be useful for attribute values that are likely to change during the lifetime of the vehicle. However, attribute values should typically not change more than once per ignition cycle, or else it should be defined as a sensor instead.\nBelow is an example of a complete attribute describing engine power\nMaxPower: datatype: uint16 type: attribute default: 0 unit: kW description: Peak power, in kilowatts, that engine can generate.It is possible to give default values also for arrays. In this case square brackets shall be used. The value for each element in the array shall be specified. The size of the array is given by the number of elements specified within the square brackets.\nExample 1: Empty Array\ndefault: []Example 2: Array with 3 elements, first element has value 1, second element value 2, third element value 0\ndefault: [1, 2, 0]Full example, array with two elements, first with value2, second with value 3:\nSeatPosCount: datatype: uint8[] type: attribute default: [2, 3] description: Number of seats across each row from the front to the rearUsing default values for structs is not allowed!",
    "description": "An attribute is an entity that has a default value, specified by its default member. The standard Vehicle Signal Specification does not include default values for all attributes. If a default value has not been specified then the OEM must define a default value matching the actual vehicle. If the standard defines a default value but it does not fit the actual vehicle, then the OEM must override the standard default value.",
    "tags": [],
    "title": "Attributes",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/attributes/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification \u003e Rule Set \u003e Data Entry",
    "content": "Specifying allowed values Optionally it is possible to define an array of allowed values, which will restrict the usage of the data entry in the implementation of the specification. It is expected, that any value not mentioned in the array is considered an error and the implementation of the specification shall react accordingly. The datatype of the array elements is the datatype defined for the data entry itself. For attributes it is possible to optionally set a default value.\nSteeringWheel.Position: datatype: string type: attribute default: 'FRONT_LEFT' allowed: ['FRONT_LEFT', 'FRONT_RIGHT'] description: Position of the steering wheel on the left or right side of the vehicle.If allowed is set, min or max cannot be defined.\nThe allowed element is an array of values, all of which must be specified in a list. Only values can be assigned to the data entry, which are specified in this list.\nThe datatype specifier gives the datatype of the individual elements of the allowed list. In general allowed: is valid for all datatypes, including integer- and float-based datatypes, unless otherwise specified.\nRecommendation on String values String values used for default and allowed statements may contain characters from the printable subset of the Unicode character set. If using COVESA VSS-tools it is recommended to use single quotes (') around values as tooling otherwise might handle literals like OFF as boolean values with unexpected result. It is recommended not to specify a dedicated value corresponding to “unknown” or “undefined” unless there is a relevant use-case for that particular signal. The background is that a signal with an array of allowed values shall be handled just as any other signal. If e.g. the value of current speed or vehicle weight is unknown, then the vehicle shall not publish the corresponding signal. Similarly, for the example above, if the steering wheel position is unknown then SteeringWheel.Position shall not be published.\nAllowed values for array datatypes The allowed keyword can also be used for signals of array datatype. In that case, allowed specifies the only valid values for array elements. The actual value of the signal is expected to contain a subset of the values specified in allowed.\nExample:\nDogBreeds: datatype: string[] type: attribute allowed: ['AKITA', 'BOXER', 'DACHSHUND', 'PAPILLON', 'PUG', 'VIZSLA'] description: Brief list of dog breeds.Examples of valid arrays:\n[] # Empty array ['BOXER'] ['PAPILLON', 'VIZSLA', 'BOXER', 'AKITA', 'DACHSHUND'] ['PUG', 'PUG'] # duplication is allowedExample of an invalid array:\n['PAPILLON', 'VIZSLA', 'LOBSTER'] # LOBSTER is not in the allowed value listAllowed for struct datatypes Please see struct documentation.",
    "description": "Specifying allowed values Optionally it is possible to define an array of allowed values, which will restrict the usage of the data entry in the implementation of the specification. It is expected, that any value not mentioned in the array is considered an error and the implementation of the specification shall react accordingly. The datatype of the array elements is the datatype defined for the data entry itself. For attributes it is possible to optionally set a default value.",
    "tags": [],
    "title": "Value Restrictions",
    "uri": "/vehicle_signal_specification/rule_set/data_entry/allowed/index.html"
  },
  {
    "breadcrumb": "",
    "content": "The Vehicle Signal Specification (VSS) is an initiative by COVESA to define a syntax and a catalog for vehicle signals. The source code and releases can be found in the VSS github repository. Some tools for parsing and converting VSS files can be found in the VSS-tools github repository.\nThis documentation gives you an overview of VSS:\nIntroduction Read this part if you want to know more about what the specification is all about, what’s in and out and how to quickly browse through the current status. Governance Introduction to VSS governance model and change log. Rule Set Get familiar with the rule set behind the specification, the structure, the format and concepts. License Information on the VSS license. Ecosystem How to use the specification? Check out the existing tools and standards to transform or make use of VSS. ",
    "description": "The Vehicle Signal Specification (VSS) is an initiative by COVESA to define a syntax and a catalog for vehicle signals. The source code and releases can be found in the VSS github repository. Some tools for parsing and converting VSS files can be found in the VSS-tools github repository.\nThis documentation gives you an overview of VSS:\nIntroduction Read this part if you want to know more about what the specification is all about, what’s in and out and how to quickly browse through the current status.",
    "tags": [],
    "title": "Vehicle Signal Specification",
    "uri": "/vehicle_signal_specification/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/vehicle_signal_specification/categories/index.html"
  },
  {
    "breadcrumb": "Vehicle Signal Specification",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/vehicle_signal_specification/tags/index.html"
  }
]
